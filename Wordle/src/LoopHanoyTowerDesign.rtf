{\rtf1\ansi\ansicpg1252\cocoartf2580
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 boolean unloadingStage = true;\
int UnloadSequence = 0;\
int[] currentLocations = new int[n];\
int currentPileSize = n;\
int currentPileLocation = 1;\
int previousMove;\
for (int i = 0, i < n, i++) \{\
	if (unloadingStage) \{\
		for (int j = 0; j<n/2; j++) \{\
			if (j == 0)\
				if (currentPileSize % 2 == 1) \{\
					Move currentPileLocation to 3\
				else if (currentPileLocation == 2) \{\
					Move currentPileLocation to 1\
					Move currentPileLocation to 3\
					Move 1 to 3\
				\} else \{\
					Move currentPileLocation to 2\
					Move currentPileLocation to 3\
					Move 2 to 3\
				\}\
				else \{\
				if (currentLocations[0] == 1)\
					move currentPileLocation to 3\
					(THEN, check mod to 2 see where to put the blocks such that the tower dies not end up the current pile)\
					\
			\}\
			Move currentPileLocation to 3\
			\
			\
\
Looks like I\'92d need the for loop to execute (n^2+n)/2 times, each time performing the \'93Tower of Hanoy\'94 algorithm, taking in a number of variables determining where the pile currently is, how big it is, and from that, determines where the new pile needs to be\
	}